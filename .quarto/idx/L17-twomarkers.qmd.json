{"title":"Lecture 17","markdown":{"headingText":"Lecture 17","containsRefs":false,"markdown":"\n## Finding partners\n\nMany statistical learning tools acan be used to identify predictors that, as a group, help us classify observations. This lecture covers a baic exercise in model building which, although extremely simplistic compared to even the most common of methods like regularized regression or random forests, can help build intuition for the challenges of building model from high dimensional noisy data. I also use this opportunity to switch to a time-to-event outcome.\n\n### Data\n\nIn this section we will be utilizing data from the `TCGA_eset` dataset.\n\nWe will be considering continuous biomarker gene expressions in the TCGA study. The phenotype of interest will be a time-to-event variable, `days_to_tumor_recurrence`\n\n```{r, message=F, warnings = F, cache=F}\nlibrary(survival)\nlibrary(curatedOvarianData)\ndata(TCGA_eset)\nGGG = as.matrix(cbind(exprs(TCGA_eset)))\nRecurrenceSurvObj = Surv( time = pData(TCGA_eset)[,\"days_to_tumor_recurrence\"],\n                          event = pData(TCGA_eset)[,\"recurrence_status\"]==\"recurrence\")\nBinaryRecurrenceAt2y = pData(TCGA_eset)[,\"days_to_tumor_recurrence\"] < 365*2\nBinaryRecurrenceAt2y[ pData(TCGA_eset)[,\"recurrence_status\"]!=\"recurrence\" & pData(TCGA_eset)[,\"days_to_tumor_recurrence\"] < 365*2 ] = NA\n```\n\n\\newpage\n\nWe will then filter out the biomarkers with low IQR. A biomarker with a low IQR generally indicates a lack of variation within the range of possible values the biomarker takes. A lack of variation in turn may suggest a lack of discriminative ability. We will filter out genes with an IQR less than or equal to $1$.\n\n```{r}\nIQR.cutoff = 1\nGGG.IQR = apply(GGG,1,IQR)\nGGG.filtered = GGG[GGG.IQR>IQR.cutoff,]\nGGG.cor = cor(t(GGG.filtered))\n```\n\n\\newpage\n\n### One Marker at the Time\n\nThen, we introduce a function that is similar to the `CompScores` function in preceeding sections. This new function, named `CompScoresTE`, will help us compute scoring metrics for recurrence based on marginal associations. Specifically, for each biomarker it computes the coefficient resulting from a Cox Proportional Hazards model fit on the biomarker, the negative log p-value of the coefficient, and the IQR of the biomarker.\n\n\\newpage\n\n```{r}\nlibrary(survival)\nlibrary(survcomp)\nCompScoresTE = function(XX,YY){\nNGenes = nrow(XX)\nScoreNames = c(\"coxRR\",\"nlpvalue\",\"IQR\")\nSSS = data.frame(matrix(NA,NGenes,length(ScoreNames)))\ncolnames(SSS) = ScoreNames\nfor (gg in 1:NGenes){\n  cox.out = coxph(YY ~ XX[gg,])\n  SSS[gg,\"nlpvalue\"] = -log(summary(cox.out)$coefficients[,\"Pr(>|z|)\"])\n  SSS[gg,\"coxRR\"] = summary(cox.out)$coefficients[,\"exp(coef)\"]\n  SSS[gg,\"IQR\"] = IQR(XX[gg,])\n}\nreturn(SSS)\n}\nScores = CompScoresTE(XX=GGG.filtered,YY=RecurrenceSurvObj)\n```\n\n\\newpage\n\nFrom this, we can resample the labels and obtain a null distribution for our data. We then set a cutoff of $1.2$ for the coefficient from the Cox Proportional Hazards model and $7$ for the negative log p-value of the coefficient. We then can tabulate which biomarkers are above these two values, in both the null and observed distributions.\n\n```{r}\nset.seed(1)\nLabelsNull = sample(1:ncol(GGG.filtered))\nRecurrenceSurvObjNull =  \n  Surv( time = pData(TCGA_eset)[LabelsNull,\"days_to_tumor_recurrence\"], event = pData(TCGA_eset)[LabelsNull,\"recurrence_status\"]==\"recurrence\")\nScoresNull = CompScoresTE(XX=GGG.filtered,YY=RecurrenceSurvObjNull)\ntable(Scores[,\"coxRR\"]>1.2)\ntable(ScoresNull[,\"coxRR\"]>1.2)\ntable(Scores[,\"nlpvalue\"]>7)\ntable(ScoresNull[,\"nlpvalue\"]>7)\n```\n\n\\newpage\n\n## Two Markers at the Time\n\n### Linear Combination\n\nWe will now compute scores for pairs and pick the best partner biomarker. We will also examine all possible additional variables in a multivariable model.\n\nHere one of the two partners is fixed (in this case the winner of the one-gene-at-the-time competition). The score for the pair is the Wald test for the model as a whole (both variables in vs no variable in).\n\n```{r}\nCompScoresPairs1 = function(XX,YY,gg0){\nNGenes = nrow(XX)\nScoreNames = c(\"coxRR0\",\"coxRRa\",\"nlpvalueW\",\"cor\")\nSSS = data.frame(matrix(NA,NGenes,length(ScoreNames)))\ncolnames(SSS) = ScoreNames\nfor (gg in (1:NGenes) ){\n  cox.out = coxph(YY ~ XX[gg,]+XX[gg0,])\n  SSS[gg,\"coxRR0\"] = summary(cox.out)$coefficients[2,\"exp(coef)\"]\n  SSS[gg,\"coxRRa\"] = summary(cox.out)$coefficients[1,\"exp(coef)\"]\n  SSS[gg,\"nlpvalueW\"] = - log ( summary(cox.out)$wald[\"pvalue\"] )\n  SSS[gg,\"cor\"] = cor(XX[gg,],XX[gg0,])\n}\nreturn(SSS)\n}\n\nTopGene = (1:nrow(Scores))[Scores[,\"nlpvalue\"]==max(Scores[,\"nlpvalue\"])]\nTopGenes7 = (1:nrow(Scores))[Scores[,\"nlpvalue\"]>7]\nScoresPairs1 = CompScoresPairs1(XX=GGG.filtered,YY=RecurrenceSurvObj,gg0=TopGene)\nTopPair1 = (1:nrow(ScoresPairs1))[ScoresPairs1[,\"nlpvalueW\"]==max(ScoresPairs1[,\"nlpvalueW\"])]\n```\n\n\\newpage\n\nWe can then plot the single predictor negative log p-value against the negative log p-value associated with multiple variables.\n\nThe lone point on the right is the best gene paired with itself, so the horizontal line represents the \"bar\" we need to meet for the pair to be better than the single.\n\nColors highlight with positive (blue) or negative (orange) correlation with the top gene, exceeding .1 in absolute value.\n\n```{r, fig.cap=\"Multivariable vs. Single Predictor Negative Log P-value Plot\"}\nplot( Scores[,\"nlpvalue\"],ScoresPairs1[,\"nlpvalueW\"], pch=\".\", cex=5, \n      ylab=\"Mutivariable negative log p-value\", \n      xlab=\"Single predictor negative log p-value\"  )\nabline(h=Scores[TopGene,\"nlpvalue\"])\nabline(0,1)\nPosCor = ScoresPairs1[ ,\"cor\"] > .1\nNegCor = ScoresPairs1[ ,\"cor\"] < - .1\npoints( Scores[ PosCor,\"nlpvalue\"],\n        ScoresPairs1[ PosCor,\"nlpvalueW\"], pch=\".\", col=\"blue\", cex=5 )\npoints( Scores[ NegCor,\"nlpvalue\"],\n        ScoresPairs1[ NegCor,\"nlpvalueW\"], pch=\".\", col=\"orange\", cex=5 )\n```\n\n::: callout-note\nComment\n:::\n\n\\newpage\n\n### Plain Averaging\n\nWe now take a slightly different approach by computing scores by pairs, picking one biomarker, and then looking at all possible \"averaging partners\".\n\n```{r}\nCompScoresPairs2 = function(XX,YY,gg0){\nNGenes = nrow(XX)\nScoreNames = c(\"coxRRa\",\"nlpvalueW\",\"cor\")\nSSS = data.frame(matrix(NA,NGenes,length(ScoreNames)))\ncolnames(SSS) = ScoreNames\nfor (gg in 1:NGenes) {\n  XXa = ( XX[gg,]+XX[gg0,] ) / 2\n  cox.out = coxph(YY ~ XXa)\n  SSS[gg,\"coxRRa\"] = summary(cox.out)$coefficients[1,\"exp(coef)\"]\n  SSS[gg,\"nlpvalueW\"] = - log ( summary(cox.out)$wald[\"pvalue\"] )\n  SSS[gg,\"cor\"] = cor(XX[gg,],XX[gg0,])\n}\nreturn(SSS)\n}\n\nScoresPairs2 = CompScoresPairs2(XX=GGG.filtered,YY=RecurrenceSurvObj,gg0=TopGene)\nTopPair2 = (1:nrow(ScoresPairs2))[ScoresPairs2[,\"nlpvalueW\"]==\n                                    max(ScoresPairs2[,\"nlpvalueW\"])]\nTopPartners11 = (1:nrow(ScoresPairs2))[ScoresPairs2[,\"nlpvalueW\"]>11]\nTopPartnersNegCor = (1:nrow(ScoresPairs2))[ScoresPairs2[,\"nlpvalueW\"]>11 & \n                                             ScoresPairs2[ ,\"cor\"] < - .1]\nTopPartnersPosCor = (1:nrow(ScoresPairs2))[ScoresPairs2[,\"nlpvalueW\"]>11 & \n                                             ScoresPairs2[ ,\"cor\"] > .1]\n```\n\n\\newpage\n\nThe plot of interest would then be the single predictor negative log p-value against the averaged predictor negative log p-value.\n\n```{r, fig.cap=\"Averaged vs. Single Predictor Negative Log P-value Plot\"}\nplot( Scores[,\"nlpvalue\"],ScoresPairs2[,\"nlpvalueW\"], pch=\".\", cex=3, xlab=\"Single variable negative log p-value\", ylab=\"Averaged predictors negative log p-value\"  )\nabline(h=Scores[TopGene,\"nlpvalue\"])\nabline(0,1)\nPosCor = ScoresPairs2[ ,\"cor\"] > .1\npoints( Scores[ PosCor,\"nlpvalue\"],ScoresPairs2[ PosCor,\"nlpvalueW\"], \n        pch=\".\", col=\"blue\", cex=5 )\nNegCor = ScoresPairs2[ ,\"cor\"] < - .1\npoints( Scores[ NegCor,\"nlpvalue\"],ScoresPairs2[ NegCor,\"nlpvalueW\"], \n        pch=\".\", col=\"orange\", cex=5 )\n```\n\n::: callout-note\nComment:\n\n-   Why is the largest p-value encountered in this point and not the previous one?\n\n-   Why the lobster claw?\n\n-   The second best gene used to be the best partner in the linear combination, but now when we simply average the result is terrible. Why?\n\nSome hints are in the following two figure, but it helps to puzzle it out for at least a bit before you proceed.\n:::\n\n\\newpage\n\nThe following table reports the correlation, exponentiated coefficient value, and the associated scores.\n\n```{r}\ncbind(ScoresPairs2[TopGenes7,c(\"cor\",\"coxRRa\")],Scores[TopGenes7,c(\"coxRR\")])\n```\n\n\\newpage\n\nWe can also plot the multivariable negative log p-value against the averaged predictor negative log p-value, further greying out those with marginal positive association with the outcome.\n\n```{r, fig.cap=\"Multivariable vs. Averaged Predictor Negative Log P-value Plot\"}\nplot( ScoresPairs1[,\"nlpvalueW\"],ScoresPairs2[,\"nlpvalueW\"], pch=\".\", cex=5, xlab=\"Mutivariable negative log p-value\", ylab=\"Averaged predictors negative log p-value\" )\nabline(0,1)\nPosCor = ScoresPairs1[ ,\"cor\"] > .1\nNegCor = ScoresPairs1[ ,\"cor\"] < - .1\nPosCoef = ScoresPairs1[,\"coxRRa\"] > 1\npoints( ScoresPairs1[ PosCor,\"nlpvalueW\"],ScoresPairs2[ PosCor,\"nlpvalueW\"], \n        pch=\".\", col=\"blue\", cex=5 )\npoints( ScoresPairs1[ NegCor,\"nlpvalueW\"],ScoresPairs2[ NegCor,\"nlpvalueW\"], \n        pch=\".\", col=\"orange\", cex=5 )\npoints( ScoresPairs1[ PosCoef,\"nlpvalueW\"],ScoresPairs2[ PosCoef,\"nlpvalueW\"], \n        pch=\".\", col=\"gray\", cex=5 )\n```\n\n\\newpage\n\nAn additional plot below compares the top gene and the top pair as identified above.\n\n```{r, fig.cap = \"Top Pair vs. Top Gene Plot\"}\nplot( GGG.filtered[TopGene,], GGG.filtered[TopPair1,])\n```\n\n\\newpage\n\n### Supplementary Figure\n\nA few miscellaneious plots, mostly to give you a sense for the fact that signal is weak and modeling is hard.\n\nWe now plot the expression values for the genes with a high combined predictor negative log p-value and that are positively correlated with the identified best gene. The orange/black points indicates recurrence/no recurrence, with recurrence being orange.\n\n```{r, fig.cap=\"Scatterplot for High Combined Predictor NLP-value and Positive Correlation with Top Gene\"}\npar(pty=\"s\")\nplot( GGG.filtered[TopGene,], GGG.filtered[TopPartnersPosCor[2],])\npoints(GGG.filtered[TopGene,], GGG.filtered[TopPartnersPosCor[2],],col=1+as.vector( pData(TCGA_eset)[,\"recurrence_status\"]==\"recurrence\") )\n```\n\n```{r, fig.cap=\"\"}\nNG = nrow(GGG.filtered)\nNS = length(as.vector(pData(TCGA_eset)[,\"recurrence_status\"]==\"recurrence\"))\npar(pty=\"m\")\nplot(GGG.filtered[TopGene,], rnorm(NS,0,.1)+as.vector(pData(TCGA_eset)[,\"recurrence_status\"]==\"recurrence\") )\n```\n\n```{r, fig.cap=\"\"}\nplot( .5 * (GGG.filtered[TopGene,]+GGG.filtered[TopPartnersPosCor[2],] ), rnorm(NS,0,.1)+as.vector(pData(TCGA_eset)[,\"recurrence_status\"]==\"recurrence\") )\n```\n\n\\newpage\n\nWe can also plot the expression values for the genes with a high combined predictor negative log p-value and that are **negatively** correlated with the identified best gene. The red/black points indicates recurrence/no recurrence, with recurrence being red in color.\n\n```{r, fig.cap=\"\"}\npar(pty=\"s\")\nplot( GGG.filtered[TopGene,], GGG.filtered[TopPartnersNegCor[1],])\npoints(GGG.filtered[TopGene,], GGG.filtered[TopPartnersNegCor[1],],col=1+as.vector( pData(TCGA_eset)[,\"recurrence_status\"]==\"recurrence\") )\n```\n\n```{r, fig.cap=\"\"}\npar(pty=\"m\")\nplot(GGG.filtered[TopGene,], rnorm(NS,0,.1)+as.vector(pData(TCGA_eset)[,\"recurrence_status\"]==\"recurrence\") )\n```\n\n```{r, fig.cap=\"\"}\nplot( .5 * (GGG.filtered[TopGene,]+GGG.filtered[TopPartnersNegCor[1],] ), rnorm(NS,0,.1)+as.vector(pData(TCGA_eset)[,\"recurrence_status\"]==\"recurrence\") )\n```\n\n\\newpage\n\nThe following figures plot the expression values for the multivariable top pairs.\n\n```{r, fig.cap=\"\"}\nplot( GGG.filtered[TopGene,], GGG.filtered[TopPair1,])\n```\n\n```{r, fig.cap=\"\"}\nplot( GGG.filtered[TopPair1,], GGG.filtered[TopPair2,])\n```\n\n\\newpage\n\nWe now plot the expression values for the top pairs by averaging.\n\n```{r, fig.cap=\"\"}\nplot( GGG.filtered[TopGene,], GGG.filtered[TopPair2,])\n```\n\n```{r, fig.cap=\"\"}\nplot( GGG.filtered[TopPair1,], GGG.filtered[TopPair2,])\n```\n\n\\newpage\n\nHere are more visualizations through a Kaplan-Meier Curve\n\n```{r}\nkm.as.one = survfit (RecurrenceSurvObj ~ 1)\nkm.by.topgene = survfit (RecurrenceSurvObj ~ GGG.filtered[TopGene,] > median(GGG.filtered[TopGene,]))\nkm.by.toppair1 = survfit (RecurrenceSurvObj ~ GGG.filtered[TopPair1,]>\nmedian(GGG.filtered[TopPair1,]))\nkm.by.toppair2 = survfit (RecurrenceSurvObj ~ GGG.filtered[TopPair2,]>median(GGG.filtered[TopPair2,]))\n```\n\n```{r, fig.cap=\"Kaplan-Meier Curve Regressed on Intercept Only\"}\nplot(km.as.one)\n```\n\n```{r, fig.cap=\"Kaplan-Meier Curve Regressed on Top Gene by Median\"}\nplot(km.by.topgene)\n```\n\n```{r, fig.cap=\"Kaplan-Meier Curve Regressed on Top Pair 1\"}\nplot(km.by.toppair1)\n```\n\n```{r, fig.cap=\"Kaplan-Meier Curve Regressed on Top Pair 2\"}\nplot(km.by.toppair2)\n```\n\n\\newpage\n\nWe can also obtain the Cox Proprotional Hazards Model.\n\n```{r}\ncox.pair1 = coxph(RecurrenceSurvObj ~ GGG.filtered[TopGene,]+GGG.filtered[TopPair1,])\nsummary(cox.pair1)\n\npair2.mean = ( GGG.filtered[TopGene,]+GGG.filtered[TopPair2,] ) / 2\ncox.pair2 = coxph(RecurrenceSurvObj ~ pair2.mean)\nsummary(cox.pair2)\n\ncor( t(GGG.filtered[c(TopGene,TopPair1,TopPair2),]) )\n```\n\n<!-- Coding that corresponds to L21c.Rmd Ends Here -->\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"L17-twomarkers.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.545","editor":"visual","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}